{% load dict_extras %}

{% if delegates and competencies %}
<form method="post" action="{% url 'instructor_assessment_save' booking.id %}" id="matrix-form">
  {% csrf_token %}

  <div class="matrix-wrap">
    <table class="matrix-table" id="assessment-matrix" aria-describedby="assessment help">
      <colgroup>
        <col class="col-comp">
        {% for _ in delegates %}<col class="col-delegate">{% endfor %}
      </colgroup>

      <thead>
        <tr>
          <th class="sticky corner">Competency</th>
          {% for d in delegates %}
            <th class="sticky top rotate" data-col="{{ forloop.counter0 }}" data-delegate-id="{{ d.id }}">
              {% with parts=d.name|split_name %}
                <div class="name-rotator">
                  <span class="first">{{ parts.0 }}</span>
                  <span class="last">{{ parts.1 }}</span>
                </div>
              {% endwith %}
            </th>
          {% endfor %}
        </tr>
      </thead>

      <tbody>
        {% for comp in competencies %}
          <tr class="{% cycle 'row-odd' 'row-even' %}">
            <th class="sticky left comp-cell">
              <div class="comp-code">{{ forloop.counter }}</div>
              <div class="comp-name">{{ comp.name }}</div>
            </th>

            {% for d in delegates %}
              {% with key=d.id|pair:comp.id %}
                {% with a=existing|get_item:key %}
                <td class="cell" data-col="{{ forloop.counter0 }}">
                  <!-- Submit 'na' when unchecked, 'c' when checked -->
                  <input type="hidden" name="level_{{ d.id }}_{{ comp.id }}" value="na">
                  <input type="checkbox"
                        name="level_{{ d.id }}_{{ comp.id }}"
                        value="c"
                        class="lv-chk"
                        {% if a and a.level == 'c' %}checked{% elif a and a.level == 'e' %}checked{% endif %}
                        aria-label="Mark {{ d.name }} competent for {{ comp.name }}" />
                </td>
                {% endwith %}
              {% endwith %}
            {% endfor %}
          </tr>
        {% endfor %}

        <!-- Outcome row -->
        <tr class="outcome-row">
          <th class="sticky left comp-cell outcome-label">
            <div class="comp-code">—</div>
            <div class="comp-name"><strong>Outcome</strong></div>
          </th>

          {% for d in delegates %}
            <td class="outcome-cell" data-col="{{ forloop.counter0 }}" data-register-id="{{ d.id }}">
              {% if d.outcome == 'pass' %}
                <span class="badge bg-success-subtle text-success-emphasis">Pass</span>
                <input type="hidden" name="outcome_{{ d.id }}" value="pending">
              {% else %}
                <select name="outcome_{{ d.id }}" class="form-select form-select-sm" aria-label="Outcome for {{ d.name }}">
                  <option value="pending" {% if d.outcome == 'pending' or not d.outcome %}selected{% endif %}>Pending</option>
                  <option value="dnf"     {% if d.outcome == 'dnf' %}selected{% endif %}>DNF</option>
                  <option value="fail"    {% if d.outcome == 'fail' %}selected{% endif %}>Fail</option>
                </select>
              {% endif %}
            </td>



          {% endfor %}
        </tr>
      </tbody>
    </table>
  </div>

  <div class="mt-3 d-flex gap-2">
  <button class="btn btn-primary btn-sm" type="submit">Save assessments</button>

  <a href="{% url 'instructor_assessment_pdf' booking.id %}"
     class="btn btn-outline-secondary btn-sm disabled"
     id="export-pdf-btn"
     aria-disabled="true"
     tabindex="-1">
    Export PDF
  </a>
</div>

<script>
(function () {
  const form = document.getElementById("matrix-form");
  if (!form) return;

  const saveUrl = form.action;
  const csrf = form.querySelector('input[name="csrfmiddlewaretoken"]').value;

  // Add parity classes once (for striping)
  (function addParityOnce() {
    const headers = form.querySelectorAll('th.top[data-col]');
    headers.forEach(h => {
      const col = parseInt(h.dataset.col || "0", 10);
      h.classList.add(col % 2 ? "is-odd" : "is-even");
    });
    const cells = form.querySelectorAll('td.cell[data-col], tr.outcome-row td.outcome-cell[data-col]');
    cells.forEach(td => {
      const col = parseInt(td.dataset.col || "0", 10);
      td.classList.add(col % 2 ? "is-odd" : "is-even");
    });
  })();

  function markColumn(col, status) {
    const header = form.querySelector('th.top[data-col="' + col + '"]');
    const cellNodes = form.querySelectorAll(
      'td.cell[data-col="' + col + '"], tr.outcome-row td.outcome-cell[data-col="' + col + '"]'
    );

    // Clear prior classes/lock
    [header, ...cellNodes].forEach(el => {
      if (!el) return;
      el.classList.remove("dnf", "fail");
      el.classList.remove("locked");
      el.removeAttribute("data-locked");
    });

    if (status === "dnf" || status === "fail") {
      [header, ...cellNodes].forEach(el => {
        if (!el) return;
        el.classList.add(status);
      });
      // Lock: do NOT disable checkboxes (they must still submit);
      // just prevent interaction.
      form.querySelectorAll('td.cell[data-col="' + col + '"]').forEach(td => {
        td.classList.add("locked");
        td.setAttribute("data-locked", "1");
      });
    }
    // pending/pass => no lock; checkboxes remain interactive and keep their state
  }

  function setOutcomeUIByReg(regId, outcome) {
    const outCell = form.querySelector('.outcome-cell[data-register-id="' + regId + '"]');
    if (!outCell) return;
    const col = outCell.dataset.col;

    if (outcome === "pass") {
      outCell.innerHTML =
        '<span class="badge bg-success-subtle text-success-emphasis">Pass</span>' +
        '<input type="hidden" name="outcome_' + regId + '" value="pending">';
      markColumn(col, "pass");
    } else {
      let sel = outCell.querySelector('select[name="outcome_' + regId + '"]');
      if (!sel) {
        outCell.innerHTML =
          '<select name="outcome_' + regId + '" class="form-select form-select-sm" aria-label="Outcome">' +
          '<option value="pending">Pending</option>' +
          '<option value="dnf">DNF</option>' +
          '<option value="fail">Fail</option>' +
          '</select>';
        sel = outCell.querySelector("select");
        sel.addEventListener("change", onOutcomeChange);
      }
      sel.value = outcome || "pending";
      markColumn(col, sel.value);
    }
  }

  function autosave(key, value, onDone) {
    const fd = new FormData();
    fd.append("csrfmiddlewaretoken", csrf);
    fd.append(key, value);

    const btn = form.querySelector('button[type="submit"]');
    if (btn) { btn.disabled = true; btn.textContent = "Saving…"; }

    fetch(saveUrl, {
      method: "POST",
      body: fd,
      headers: { "X-Requested-With": "XMLHttpRequest" },
      credentials: "same-origin",
    })
      .then(r => r.ok ? r.json() : null)
      .then(data => {
        if (data && data.ok && data.reg_id) {
          setOutcomeUIByReg(data.reg_id, data.outcome || "pending");
        }
        if (onDone) onDone(data);
      })
      .catch(() => { if (onDone) onDone(null); })
      .finally(() => {
        if (btn) { btn.disabled = false; btn.textContent = "Save assessments"; }
      });
  }

  function onLevelChange(e) {
    const cb = e.target;
    if (cb.type !== "checkbox") return;

    // Guard: if the column is locked, revert the visual toggle immediately (no submit)
    const td = cb.closest("td.cell");
    if (td && td.classList.contains("locked")) {
      cb.checked = !cb.checked; // revert
      return;
    }

    const key = cb.name;                 // "level_<reg>_<comp>"
    const value = cb.checked ? "c" : "na";
    autosave(key, value);
  }

  function onOutcomeChange(e) {
    const sel = e.target;
    const key = sel.name;                // "outcome_<reg>"
    const value = sel.value;             // pending/dnf/fail
    // Local lock/tint immediately
    const td = sel.closest("td.outcome-cell");
    if (td && td.dataset.col) {
      markColumn(td.dataset.col, value);
    }
    autosave(key, value);
  }

  // Wire up inputs
  form.querySelectorAll('td.cell input[type="checkbox"][name^="level_"]').forEach(cb => {
    cb.addEventListener("change", onLevelChange);
  });
  form.querySelectorAll('tr.outcome-row select[name^="outcome_"]').forEach(sel => {
    sel.addEventListener("change", onOutcomeChange);
  });

  // Initial lock/tint for DNF/Fail on load
  form.querySelectorAll('tr.outcome-row .outcome-cell').forEach(cell => {
    const sel = cell.querySelector('select[name^="outcome_"]');
    if (!sel) return;
    const val = sel.value;
    if (val === "dnf" || val === "fail") {
      markColumn(cell.dataset.col, val);
    }
  });
})();
</script>


</form>

<p id="assessment" class="visually-hidden">
  Tick a box when the delegate is competent for that competency. A column auto-sets to “Pass” when every box is ticked.
</p>

<style>
/* === container === */
.matrix-wrap {
  display: inline-block;
  max-width: 120%;
  max-height: 60vh;
  overflow: auto;
  border: 1px solid var(--bs-border-color, #dee2e6);
  border-radius: .5rem;
  background: #fff;
  position: relative; /* ensure a sane stacking context */
}

/* === table === */
.matrix-table {
  --delegate-col-width: 110px;
  --zebra-even:  #d1deec;
  --zebra-odd:   #ffffff;
  --zebra-hover: #c4d4ea;

  border-collapse: separate;
  width: auto;               /* only as wide as needed */
  table-layout: fixed;
  font-size: .9rem;
  border-spacing: 0;
}

/* col widths */
.col-comp { width: 240px; }
.col-delegate { width: var(--delegate-col-width); }

/* base cells & crisp vertical borders */
.matrix-table th,
.matrix-table td {
  border-bottom: 1px solid #dfe3e7;
  border-right: 1px solid #edf0f3;
  padding: .42rem;
  text-align: center;
  vertical-align: middle;
}

/* zebra striping */
.matrix-table tbody tr.row-odd  { background: var(--zebra-odd); }
.matrix-table tbody tr.row-even { background: var(--zebra-even); }
.matrix-table tbody tr:hover    { background: var(--zebra-hover); }

/* Outcome row style */
.matrix-table tr.outcome-row th.outcome-label {
  position: sticky;
  left: 0;
  z-index: 260;                 /* above body cells & overlays */
  background: #fff;
  box-shadow: 1px 0 0 rgba(0,0,0,.05);
}
.matrix-table tr.outcome-row .outcome-cell {
  background: #f8f9fb;
  border-top: 2px solid #e3e7ec;
}

/* Sticky */
.sticky { position: sticky; background: transparent; }
.sticky.top    { top: 0;    z-index: 250; background: #fff; }
.sticky.corner { top: 0; left: 0; z-index: 300; background: #fff; }

/* left sticky column ALWAYS above overlays; keep zebra look */
.sticky.left {
  left: 0;
  text-align: left;
  z-index: 270 !important;
  background: #fff; /* overridden per-row below */
}
tbody tr.row-even th.sticky.left { background: var(--zebra-even) !important; }
tbody tr.row-odd  th.sticky.left { background: var(--zebra-odd)  !important; }

/* first column content */
.comp-code { font-weight: 600; color: #6c757d; font-size: .85rem; }
.comp-name { font-size: .9rem; line-height: 1.15; }

/* header names (vertical) */
.rotate { height: 92px; padding: 0 .15rem; }
.name-rotator {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  gap: .1rem;
  transform: rotate(-90deg);
  transform-origin: center;
  white-space: nowrap;
}
.name-rotator .first { font-weight: 600; }
.name-rotator .last  { color: #6c757d; font-size: .9em; }

/* checkboxes */
.cell .lv-chk { width: 16px; height: 16px; }

/* PASS tint */
td.cell.pass, td.outcome-cell.pass { background: #e6f7ea !important; box-shadow: none !important; }
th.top.pass { background: #def3e6 !important; box-shadow: none !important; }

/* ===== Column tint underlays (robust) ===== */
/* Each cell/heading hosts an underlay clipped to itself */
.matrix-table td.cell,
.matrix-table td.outcome-cell {
  position: relative;
  overflow: hidden;     /* clip ::before inside each cell */
}

/* keep the header row sticky */
.matrix-table th.top,
.sticky.top {
  position: sticky;
  top: 0;
  z-index: 250;
  background: #fff;
}


/* content stays above the underlay */
.matrix-table td.cell > *,
.matrix-table td.outcome-cell > *,
.matrix-table th.top > * {
  position: relative;
  z-index: 1;
}

/* DNF underlay (odd/even striping) */
td.cell.dnf.is-odd::before,
td.outcome-cell.dnf.is-odd::before,
th.top.dnf.is-odd::before,
td.cell.dnf.is-even::before,
td.outcome-cell.dnf.is-even::before,
th.top.dnf.is-even::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 0;
}
td.cell.dnf.is-odd::before,
td.outcome-cell.dnf.is-odd::before,
th.top.dnf.is-odd::before { background: rgba(255,200,0,.20); }
td.cell.dnf.is-even::before,
td.outcome-cell.dnf.is-even::before,
th.top.dnf.is-even::before { background: rgba(255,185,0,.28); }

/* FAIL underlay (odd/even striping) */
td.cell.fail.is-odd::before,
td.outcome-cell.fail.is-odd::before,
th.top.fail.is-odd::before,
td.cell.fail.is-even::before,
td.outcome-cell.fail.is-even::before,
th.top.fail.is-even::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 0;
}
td.cell.fail.is-odd::before,
td.outcome-cell.fail.is-odd::before,
th.top.fail.is-odd::before { background: rgba(220,53,69,.18); }
td.cell.fail.is-even::before,
td.outcome-cell.fail.is-even::before,
th.top.fail.is-even::before { background: rgba(220,53,69,.28); }

/* Lock a DNF/Fail column WITHOUT disabling inputs (so ticks still submit) */
td.cell.locked input[type="checkbox"] { pointer-events: none; }

/* Do not fade disabled checkboxes if any appear */
.cell input[type="checkbox"]:disabled { opacity: 1; filter: none; }

/* subtle sticky shadows */
thead tr th.sticky { box-shadow: 0 1px 0 rgba(0,0,0,.05); }
tbody th.sticky.left { box-shadow: 1px 0 0 rgba(0,0,0,.05); }

/* outcome select / badge */
.outcome-cell { position: relative; }
.outcome-badge { display: inline-block; }
.d-none { display: none !important; }
</style>


{% else %}
  <div class="text-muted">No delegates or competencies found for this booking.</div>
{% endif %}

<script>
(function () {
  const form = document.getElementById("matrix-form");
  if (!form) return;

  const saveUrl = form.action;
  const csrf = form.querySelector('input[name="csrfmiddlewaretoken"]').value;

  function autosaveKV(key, val) {
    const fd = new FormData();
    fd.append("csrfmiddlewaretoken", csrf);
    fd.append(key, val);
    return fetch(saveUrl, {
      method: "POST",
      body: fd,
      headers: { "X-Requested-With": "XMLHttpRequest" },
      credentials: "same-origin",
    }).then(r => (r.ok ? r.json() : null)).catch(() => null);
  }

  // Update closure UI (badge + button) without a full reload
  function refreshClosureState() {
    // Count outcomes from visible selects (pass/dnf/fail/pending)
    const selects = Array.from(document.querySelectorAll('.outcome-cell select[name^="outcome_"]'));
    const values  = selects.map(s => (s.value || "").toLowerCase());
    const total   = selects.length;
    const pending = values.filter(v => v === "" || v === "pending").length;
    const complete = pending === 0 && total > 0;

    // Status pill
    const pill = document.getElementById("assessments-status-pill");
    if (pill) {
      if (complete) {
        pill.className = "badge bg-success";
        pill.textContent = "OK";
      } else {
        pill.className = "badge bg-warning text-dark";
        pill.textContent = 'Delegate(s) still "Pending" on matrix';
      }
    }

    // Manual checkbox for assessments
    const manualCb = document.getElementById("closure-assess-manual");
    const manualHidden = document.getElementById("hf-assess-manual"); // hidden field in the form
    if (manualCb) {
      if (complete) {
        manualCb.checked = false;          // no manual needed when complete
        manualCb.disabled = true;          // disable the checkbox
        if (manualHidden) manualHidden.value = "0";
      } else {
        manualCb.disabled = false;         // let them tick manual if incomplete
        // keep hidden value in sync with current checkbox state
        if (manualHidden) manualHidden.value = manualCb.checked ? "1" : "0";
      }
    }

    // Close course button
    const btn = document.getElementById("close-course-btn");
    if (btn) btn.disabled = !complete;
  }

  // expose to other handlers in this IIFE
  window.__refreshClosureState = refreshClosureState;

  // initial compute
  refreshClosureState();
})();
</script>

<script>
(function () {
  const MATRIX_SEL = '#assessment-matrix';

  function colAllTicks(colIdx) {
    const boxes = [...document.querySelectorAll(
      `${MATRIX_SEL} td.cell[data-col="${colIdx}"] .lv-chk`
    )];
    return boxes.length > 0 && boxes.every(b => b.checked);
  }

  function colEffectiveFinal(colIdx) {
    const th = document.querySelector(`${MATRIX_SEL} thead th[data-col="${colIdx}"]`);
    const outTd = document.querySelector(`${MATRIX_SEL} .outcome-row td.outcome-cell[data-col="${colIdx}"]`);
    if (!th || !outTd) return false;

    // 1) UI classes already applied?
    if (th.classList.contains('pass') || outTd.classList.contains('pass')) return true;
    if (th.classList.contains('dnf')  || outTd.classList.contains('dnf'))  return true;
    if (th.classList.contains('fail') || outTd.classList.contains('fail')) return true;

    // 2) All ticks in the column => auto Pass
    if (colAllTicks(colIdx)) return true;

    // 3) Fall back to the select value
    const sel = outTd.querySelector('select.outcome-select');
    const v = sel ? (sel.value || '').toLowerCase() : 'pending';
    return v !== 'pending';
  }

  function matrixAllFinal() {
    const cols = [...document.querySelectorAll(`${MATRIX_SEL} thead th[data-col]`)];
    if (cols.length === 0) return false;
    return cols.every(th => colEffectiveFinal(th.dataset.col));
  }

  function updateExportBtn() {
    const btn = document.getElementById('export-pdf-btn');
    if (!btn) return;

    if (matrixAllFinal()) {
      btn.classList.remove('disabled');
      btn.removeAttribute('aria-disabled');
      btn.removeAttribute('tabindex');
    } else {
      btn.classList.add('disabled');
      btn.setAttribute('aria-disabled', 'true');
      btn.setAttribute('tabindex', '-1');
    }
  }

  // Initial check
  document.addEventListener('DOMContentLoaded', updateExportBtn);

  // Recheck on any changes inside the matrix (ticks or outcomes)
  document.addEventListener('change', (e) => {
    if (e.target.closest(MATRIX_SEL)) updateExportBtn();
  });

  // If your autosave code runs after ajax, call updateExportBtn() on success too
  window.updateExportBtn = updateExportBtn; // expose if needed by other scripts
})();
</script>

<script>
(function () {
  const saveUrl = "{% url 'instructor_assessment_save' booking.id %}";
  const csrf = document.querySelector('#matrix-form input[name=csrfmiddlewaretoken]')?.value;

  function autosaveField(name, value) {
    if (!csrf) return;
    const fd = new FormData();
    fd.append('csrfmiddlewaretoken', csrf);
    fd.append(name, value);

    fetch(saveUrl, { method: 'POST', body: fd, headers: { 'X-Requested-With': 'XMLHttpRequest' } })
      .then(r => r.ok ? r.json().catch(() => ({})) : {})
      .then(payload => {
        // Ask the closure tab to refresh itself if the page exposes a helper
        if (window.applyClosurePayload && payload) window.applyClosurePayload(payload);
        if (window.updateExportBtn) window.updateExportBtn(); // keep Export PDF toggle correct
      })
      .catch(() => {});
  }

  // 1) AUTOSAVE OUTCOME SELECT (already present for you; keep it if you have it)
  document.addEventListener('change', function (e) {
    const sel = e.target.closest('.outcome-select');
    if (!sel) return;
    // name pattern in the form is outcome_<register_id>
    const regId = sel.closest('td.outcome-cell')?.dataset.col; // not used for name; just for UI if needed
    const inputName = sel.getAttribute('name'); // "outcome_<register_id>"
    if (inputName) autosaveField(inputName, sel.value);
  });

  // 2) AUTOSAVE CHECKBOX LEVELS  <-- THIS IS THE NEW PART
  // Your checkboxes already have name="level_<register>_<competency>" and value="c";
  // we send 'c' when checked, 'na' when unchecked – the view maps 'c'/'na' to the model.
  document.addEventListener('change', function (e) {
    const box = e.target.closest('.lv-chk');
    if (!box) return;
    const name = box.getAttribute('name');     // e.g. "level_123_45"
    if (!name) return;
    const value = box.checked ? 'c' : 'na';
    autosaveField(name, value);
  });

})();
</script>

