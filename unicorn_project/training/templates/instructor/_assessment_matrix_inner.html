{% load dict_extras %}

{% if delegates and competencies %}
<form method="post" action="{% url 'instructor_assessment_save' booking.id %}" id="matrix-form">
  {% csrf_token %}

  <div class="matrix-wrap">
    <table class="matrix-table" id="assessment-matrix" aria-describedby="assessment help">
      <colgroup>
        <col class="col-comp">
        {% for _ in delegates %}<col class="col-delegate">{% endfor %}
      </colgroup>

      <thead>
        <tr>
          <th class="sticky corner">Competency</th>
          {% for d in delegates %}
            <th class="sticky top rotate" data-col="{{ forloop.counter0 }}" data-register-id="{{ d.register_id|default:d.id }}">
              {% with parts=d.name|split_name %}
                <div class="name-rotator">
                  <span class="first">{{ parts.0 }}</span>
                  <span class="last">{{ parts.1 }}</span>
                </div>
              {% endwith %}
            </th>
          {% endfor %}
        </tr>
      </thead>

      <tbody>
        {% for comp in competencies %}
          <tr class="{% cycle 'row-odd' 'row-even' %}">
            <th class="sticky left comp-cell">
              <div class="comp-code">{{ forloop.counter }}</div>
              <div class="comp-name">{{ comp.name }}</div>
            </th>

            {% for d in delegates %}
              {% with key=d.id|pair:comp.id %}
                {% with a=existing|get_item:key %}
                <td class="cell" data-col="{{ forloop.counter0 }}">
                  <input type="hidden"
                         name="level_{{ d.id }}_{{ comp.id }}"
                         value="{% if a and a.level %}{{ a.level }}{% else %}na{% endif %}"
                         class="level-input" />
                  <input type="checkbox"
                        class="lv-chk assess-toggle"
                        data-register="{{ d.register_id|default:d.id }}"
                        data-competency="{{ comp.id }}"
                        {% if a and a.level == 'c' %}checked{% elif a and a.level == 'e' %}checked{% endif %}
                        {% if a and a.is_locked %}disabled title="Carried forward from DNF (locked)"{% endif %}
                        aria-label="Mark {{ d.name }} competent for {{ comp.name }}" />
                  {% if a and a.is_locked %}
                    <span class="lock-indicator" aria-hidden="true">üîí</span>
                  {% endif %}
                </td>
                {% endwith %}
              {% endwith %}
            {% endfor %}
          </tr>
        {% endfor %}

        <!-- Outcome row -->
        <tr class="outcome-row">
          <th class="sticky left comp-cell outcome-label">
            <div class="comp-code">‚Äî</div>
            <div class="comp-name"><strong>Outcome</strong></div>
          </th>

          {% for d in delegates %}
            <td class="outcome-cell" data-col="{{ forloop.counter0 }}">
              <!-- hidden value that mirrors the effective outcome -->
              <input type="hidden" name="outcome_{{ d.id }}" class="outcome-input" value="{{ d.outcome|default:'pending' }}" />
              <!-- visible selector for manual states (no 'Pass') -->
              <select class="form-select form-select-sm outcome-select"
                      data-register="{{ d.register_id|default:d.id }}"
                      aria-label="Outcome for {{ d.name }}">

                <option value="pending" {% if d.outcome == 'pending' or not d.outcome %}selected{% endif %}>Pending</option>
                <option value="dnf"     {% if d.outcome == 'dnf' %}selected{% endif %}>DNF</option>
                <option value="fail"    {% if d.outcome == 'fail' %}selected{% endif %}>Fail</option>
              </select>
              <!-- shown only when auto-pass (all boxes ticked) -->
              <span class="badge bg-success-subtle text-success-emphasis outcome-badge d-none">Pass</span>
            </td>

          {% endfor %}
        </tr>
      </tbody>
    </table>
  </div>

  <div class="mt-3 d-flex gap-2">
    <noscript>
      <button class="btn btn-primary btn-sm" type="submit">Save assessments</button>
    </noscript>

    <a href="{% url 'instructor_assessment_pdf' booking.id %}"
      class="btn btn-outline-secondary btn-sm disabled"
      id="export-pdf-btn"
      aria-disabled="true"
      tabindex="-1">
      Export PDF
    </a>
  </div>


</form>

<p id="assessment" class="visually-hidden">
  Tick a box when the delegate is competent for that competency. A column auto-sets to ‚ÄúPass‚Äù when every box is ticked.
</p>

<style>
/* === container === */
.matrix-wrap {
  display: inline-block;
  max-width: 120%;
  max-height: 60vh;
  overflow: auto;
  border: 1px solid var(--bs-border-color, #dee2e6);
  border-radius: .5rem;
  background: #fff;
}

/* === table === */
.matrix-table {
  --delegate-col-width: 110px;   /* adjust if needed */
  --zebra-even:  #d1deec;        /* darker zebra */
  --zebra-odd:   #ffffff;
  --zebra-hover: #c4d4ea;        /* darker hover */

  border-collapse: separate;
  width: auto;                   /* only as wide as needed */
  table-layout: fixed;
  font-size: .9rem;
  border-spacing: 0;
}

/* col widths */
.col-comp { width: 240px; }
.col-delegate { width: var(--delegate-col-width); }

/* base cells */
.matrix-table th,
.matrix-table td {
  border-bottom: 1px solid #dfe3e7;
  border-right: 1px solid #edf0f3;
  padding: .42rem;
  text-align: center;
  vertical-align: middle;
}

/* zebra striping */
.matrix-table tbody tr.row-odd  { background: var(--zebra-odd); }
.matrix-table tbody tr.row-even { background: var(--zebra-even); }
.matrix-table tbody tr:hover    { background: var(--zebra-hover); }

/* Outcome row style */
.matrix-table tr.outcome-row th.outcome-label {
  position: sticky;
  left: 0;
  z-index: 4;
  background: #fff;
  box-shadow: 1px 0 0 rgba(0,0,0,.05);
}
.matrix-table tr.outcome-row .outcome-cell {
  background: #f8f9fb;
  border-top: 2px solid #e3e7ec;
}

/* Sticky (inherit zebra for left column; header stays white) */
.sticky { position: sticky; z-index: 2; background: transparent; }
.sticky.top { top: 0; z-index: 5; background: #fff; }
.sticky.left { left: 0; text-align: left; z-index: 4; background: inherit; }
.sticky.corner { top: 0; left: 0; z-index: 6; background: #fff; }

/* first column content */
.comp-code { font-weight: 600; color: #6c757d; font-size: .85rem; }
.comp-name { font-size: .9rem; line-height: 1.15; }

/* header names (vertical) */
.rotate { height: 92px; padding: 0 .15rem; }
.name-rotator {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  gap: .1rem;
  transform: rotate(-90deg);
  transform-origin: center;
  white-space: nowrap;
}
.name-rotator .first { font-weight: 600; }
.name-rotator .last  { color: #6c757d; font-size: .9em; }

/* checkboxes */
.cell .lv-chk { width: 16px; height: 16px; }

/* === Column outcome overlays === */
td.cell.dnf.is-odd,      td.outcome-cell.dnf.is-odd,      th.top.dnf.is-odd      { box-shadow: inset 0 0 0 9999px rgba(255, 200, 0, 0.20); }
td.cell.dnf.is-even,     td.outcome-cell.dnf.is-even,     th.top.dnf.is-even     { box-shadow: inset 0 0 0 9999px rgba(255, 185, 0, 0.28); }

td.cell.fail.is-odd,     td.outcome-cell.fail.is-odd,     th.top.fail.is-odd     { box-shadow: inset 0 0 0 9999px rgba(220, 53, 69, 0.18); }
td.cell.fail.is-even,    td.outcome-cell.fail.is-even,    th.top.fail.is-even    { box-shadow: inset 0 0 0 9999px rgba(220, 53, 69, 0.28); }

/* PASS */
td.cell.pass,            td.outcome-cell.pass             { background: #e6f7ea !important; box-shadow: none !important; }
th.top.pass                                          { background: #def3e6 !important; box-shadow: none !important; }

/* subtle sticky shadows */
thead tr th.sticky { box-shadow: 0 1px 0 rgba(0,0,0,.05); }
tbody th.sticky.left { box-shadow: 1px 0 0 rgba(0,0,0,.05); }

/* outcome select / badge */
.outcome-cell { position: relative; }
.outcome-badge { display: inline-block; }
.d-none { display: none !important; }

.lock-indicator { opacity: 0.7; font-size: 0.9em; margin-left: .2rem; }

</style>

<script>
(function () {
  const table = document.getElementById('assessment-matrix');
  if (!table) return;

  const exportBtn = document.getElementById('export-pdf-btn');

  // --- endpoints ------------------------------------------------------------
  const AUTOSAVE_URL = "{% url 'instructor_assessment_autosave' booking.pk %}";
  const OUTCOME_URL  = "{% url 'instructor_assessment_outcome_autosave' booking.pk %}";

  // --- csrf helper ----------------------------------------------------------
  function getCookie(name){
    const m = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
    return m ? m.pop() : '';
  }
  const CSRF = getCookie('csrftoken');

  // --- small utils ----------------------------------------------------------
  function getRegisterIdForColumn(colIndex){
    const th = table.querySelector(`thead th.top[data-col="${colIndex}"]`);
    return th ? th.getAttribute('data-register-id') : null;
  }


  function tagParity(){
    table.querySelectorAll('thead th.top').forEach(th => {
      const idx = parseInt(th.dataset.col, 10);
      th.classList.toggle('is-even', idx % 2 === 0);
      th.classList.toggle('is-odd',  idx % 2 === 1);
    });
    table.querySelectorAll('td.cell, td.outcome-cell').forEach(td => {
      const idx = parseInt(td.dataset.col, 10);
      td.classList.toggle('is-even', idx % 2 === 0);
      td.classList.toggle('is-odd',  idx % 2 === 1);
    });
  }

  function refreshExportState(){
    const vals = Array.from(table.querySelectorAll('.outcome-input')).map(i => i.value);
    const allDecided = vals.length > 0 && vals.every(v => v === 'pass' || v === 'fail' || v === 'dnf');
    if (!exportBtn) return;
    if (allDecided) {
      exportBtn.classList.remove('disabled');
      exportBtn.removeAttribute('aria-disabled');
      exportBtn.removeAttribute('tabindex');
    } else {
      exportBtn.classList.add('disabled');
      exportBtn.setAttribute('aria-disabled','true');
      exportBtn.setAttribute('tabindex','-1');
    }
  }

  // ---- Live update of the Course closure pane (assessments section) ----
  function updateClosurePaneAssessStatus(){
    const vals = Array.from(table.querySelectorAll('.outcome-input')).map(i => i.value);
    const assessAllOk = vals.length > 0 && vals.every(v => v === 'pass' || v === 'fail' || v === 'dnf');

    const pane      = document.getElementById('closure-pane');
    const badge     = document.getElementById('closure-assess-status');
    const manualBox = document.getElementById('closure-assess-manual');
    const regManual = document.getElementById('closure-register-manual');
    const closeBtn  = document.getElementById('close-course-btn');

    if (!pane || !badge || !manualBox) return;

    pane.dataset.assessOk = assessAllOk ? 'true' : 'false';

    if (assessAllOk) {
      manualBox.checked = false;
      manualBox.disabled = true;
      badge.textContent = 'OK';
      badge.className = 'badge bg-success';
    } else {
      manualBox.disabled = false;
      if (manualBox.checked) {
        badge.textContent = 'Manual submission(s)';
        badge.className = 'badge bg-primary';
      } else {
        badge.textContent = 'Delegate(s) still "Pending" on matrix';
        badge.className = 'badge bg-warning text-dark';
      }
    }

    const assessOkish = assessAllOk || manualBox.checked;
    const registersOk = (pane.dataset.registersOk === 'true');
    const regOkish = registersOk || (regManual && regManual.checked);

    const allOkish = assessOkish && regOkish;
    if (closeBtn) closeBtn.style.display = allOkish ? '' : 'none';
  }
  // ----------------------------------------------------------------------

  // --- server calls ------------------------------------------------------
  function autosaveCell(regId, compId, checked){
    return fetch(AUTOSAVE_URL, {
      method: 'POST',
      credentials: 'same-origin',
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'X-CSRFToken': CSRF,
        'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
      },
      body: new URLSearchParams({
        register_id: regId,
        competency_id: compId,
        checked: checked ? 'true' : 'false'
      })
    }).then(async (r) => {
      let data = null;
      try { data = await r.json(); } catch(_) {}
      if (!r.ok || (data && data.ok === false)) {
        const msg = (data && data.error) ? data.error : (r.status + ' ' + r.statusText);
        throw new Error(msg);
      }
      return data || { ok: true };
    });
  }

  function autosaveOutcome(registerId, outcome){
    return fetch(OUTCOME_URL, {
      method: 'POST',
      credentials: 'same-origin',
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'X-CSRFToken': CSRF,
        'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
      },
      body: new URLSearchParams({ register_id: registerId, outcome })
    }).then(async (r) => {
      let data = null;
      try { data = await r.json(); } catch(_) {}
      if (!r.ok || (data && data.ok === false)) {
        const msg = (data && data.error) ? data.error : (r.status + ' ' + r.statusText);
        throw new Error(msg);
      }
      return data || { ok: true };
    });
  }
  // ----------------------------------------------------------------------

  // --- UI helpers --------------------------------------------------------
  function applyOutcomeClasses(colIndex, outcome){
    const header = table.querySelector(`thead th.top[data-col="${colIndex}"]`);
    const cells  = table.querySelectorAll(`td.cell[data-col="${colIndex}"]`);
    const outTd  = table.querySelector(`td.outcome-cell[data-col="${colIndex}"]`);
    const outSel = outTd?.querySelector('.outcome-select');
    const outInp = outTd?.querySelector('.outcome-input');
    const badge  = outTd?.querySelector('.outcome-badge');

    [header, ...cells, outTd].forEach(el => {
      if(!el) return;
      el.classList.remove('dnf','fail','pass');
      el.style.boxShadow = '';
    });

    if (badge && outSel) {
      if (outcome === 'pass') {
        badge.classList.remove('d-none');
        outSel.classList.add('d-none');
        outSel.disabled = true;
      } else {
        badge.classList.add('d-none');
        outSel.classList.remove('d-none');
        outSel.disabled = false;
        outSel.value = ['pending','dnf','fail'].includes(outcome) ? outcome : 'pending';
      }
    }

    if (outInp) outInp.value = outcome;

    const chks = table.querySelectorAll(`td.cell[data-col="${colIndex}"] .lv-chk`);
    if (outcome === 'dnf' || outcome === 'fail') {
      chks.forEach(chk => { chk.disabled = true; });
    } else {
      chks.forEach(chk => { chk.disabled = false; });
    }

    if (outcome === 'pending') { 
      refreshExportState();
      updateClosurePaneAssessStatus();
      return; 
    }

    if (outcome === 'dnf') {
      header?.classList.add('dnf');
      outTd?.classList.add('dnf');
      cells.forEach(td => td.classList.add('dnf'));
    } else if (outcome === 'fail') {
      header?.classList.add('fail');
      outTd?.classList.add('fail');
      cells.forEach(td => td.classList.add('fail'));
    } else if (outcome === 'pass') {
      header?.classList.add('pass');
      outTd?.classList.add('pass');
      cells.forEach(td => td.classList.add('pass'));
    }

    refreshExportState();
    updateClosurePaneAssessStatus();
  }

  function updateColumnState(colIndex){
    const cells = table.querySelectorAll(`td.cell[data-col="${colIndex}"]`);
    if(!cells.length) return;

    let allChecked = true;
    cells.forEach(td => { if(!td.querySelector('.lv-chk').checked) allChecked = false; });

    const outTd  = table.querySelector(`td.outcome-cell[data-col="${colIndex}"]`);
    const outSel = outTd?.querySelector('.outcome-select');
    const outInp = outTd?.querySelector('.outcome-input');
    const manual = outSel ? outSel.value : 'pending';

    const outcome = allChecked ? 'pass' : (manual === 'dnf' || manual === 'fail' ? manual : 'pending');

    // capture previous BEFORE UI apply
    const prev = (outInp && outInp.value) ? outInp.value : 'pending';

    applyOutcomeClasses(colIndex, outcome);

    cells.forEach(td => {
      const chk = td.querySelector('.lv-chk');
      const hidden = td.querySelector('.level-input');
      if (hidden) hidden.value = chk.checked ? 'c' : 'na';
    });

    const regId = getRegisterIdForColumn(colIndex);
    if (regId && outcome !== prev) {
      if (outInp) outInp.value = outcome;
      autosaveOutcome(regId, outcome).catch(err => {
        console.error('Autosave outcome failed:', err && err.message ? err.message : err);
      });
    }
  }
  // ----------------------------------------------------------------------

  // --- wire UI events ----------------------------------------------------
  table.querySelectorAll('td.cell').forEach(td => {
    const chk = td.querySelector('.lv-chk');
    const setVal = () => {
      const hidden = td.querySelector('.level-input');
      if (hidden) hidden.value = chk.checked ? 'c' : 'na';
    };
    chk.addEventListener('change', () => {
      setVal();
      updateColumnState(td.dataset.col);

      const regId = chk.getAttribute('data-register');
      const compId = chk.getAttribute('data-competency');
      autosaveCell(regId, compId, chk.checked).catch((err) => {
        console.error('Autosave failed:', err && err.message ? err.message : err);
        chk.checked = !chk.checked;
        setVal();
        updateColumnState(td.dataset.col);
        alert('Saving failed. Please try again.');
      });
    });
    setVal();
  });

  table.querySelectorAll('td.outcome-cell .outcome-select').forEach(sel => {
    const colIndex = sel.closest('td.outcome-cell').dataset.col;
    sel.addEventListener('change', () => {
      updateColumnState(colIndex);

      const regId = sel.getAttribute('data-register');
      const outcome = sel.value;

      fetch(OUTCOME_URL, {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'X-Requested-With': 'XMLHttpRequest',
          'X-CSRFToken': CSRF,
          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
        },
        body: new URLSearchParams({ register_id: regId, outcome })
      })
      .then(async (r) => {
        let data = null;
        try { data = await r.json(); } catch(_) {}
        if (!r.ok || (data && data.ok === false)) {
          const msg = (data && data.error) ? data.error : (r.status + ' ' + r.statusText);
          throw new Error(msg);
        }
        return data || { ok: true };
      })
      .catch(err => {
        console.error('Outcome autosave failed:', err && err.message ? err.message : err);
        alert('Saving failed. Please try again.');
        updateColumnState(colIndex);
      });
    });
  });
  // ----------------------------------------------------------------------

  // --- initial paint + persist (this is the important bit) ----------------
  tagParity();

  function computeOutcomeForCol(colIndex){
    const cells = table.querySelectorAll(`td.cell[data-col="${colIndex}"]`);
    let allChecked = true;
    cells.forEach(td => {
      const chk = td.querySelector('.lv-chk');
      if (!chk || !chk.checked) allChecked = false;

      const hidden = td.querySelector('.level-input');
      if (hidden) hidden.value = chk && chk.checked ? 'c' : 'na';
    });

    const outTd  = table.querySelector(`td.outcome-cell[data-col="${colIndex}"]`);
    const outSel = outTd?.querySelector('.outcome-select');
    const outInp = outTd?.querySelector('.outcome-input');
    const manual = outSel ? outSel.value : 'pending';

    const outcome = allChecked ? 'pass' : ((manual === 'dnf' || manual === 'fail') ? manual : 'pending');

    // ‚úÖ NEW: always mirror the computed outcome into the hidden input immediately
    if (outInp) outInp.value = outcome;

    return { outcome, outInp };
  }


  function persistOutcomeIfChanged(colIndex, outInp, outcome){
    const prev = outInp ? outInp.value : 'pending';
    applyOutcomeClasses(colIndex, outcome);
    if (outInp) outInp.value = outcome;

    const regId = getRegisterIdForColumn(colIndex);
    if (regId && outcome !== prev) {
      autosaveOutcome(regId, outcome).catch(err => {
        console.error('Initial outcome persist failed:', err && err.message ? err.message : err);
      });
    }
  }

  Array.from(table.querySelectorAll('thead th.top')).forEach(th => {
    const col = th.dataset.col;
    const { outcome, outInp } = computeOutcomeForCol(col);
    persistOutcomeIfChanged(col, outInp, outcome);
  });

  refreshExportState();
  updateClosurePaneAssessStatus();
  // ----------------------------------------------------------------------

})();
</script>

{% else %}
  <div class="text-muted">No delegates or competencies found for this booking.</div>
{% endif %}